{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"nuxt介绍","slug":"nuxt介绍","date":"2019-08-12T07:24:43.000Z","updated":"2020-04-14T07:32:13.235Z","comments":true,"path":"2019/08/12/nuxt介绍/","link":"","permalink":"http://yoursite.com/2019/08/12/nuxt%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"1.Nuxt.js 1.1 简介 Nuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染(SSR)的 Vue 应用提供了极其便利的开发体验。 Vue.js是开发SPA单页面应用的，传统的SPA应用是将bundle.js从服务端获取，然后在客户端解析并挂载到dom。 Nuxt这个框架是用Vue开发多页应用，并在服务端渲染。我们可以将组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记&quot;激活&quot;为客户端上完全可交互的应用程序。 Nuxt适合做新闻、博客、电影、咨询这样的需要搜索引擎提供流量的项目。如果你要做到是移动端项目，就没有必要用nuxt这个框架了。 123456Nuxt.js有如下特点：Vue 2 ： nuxt是基于Vue2开发的Vue Router ： nuxt整合了路由功能，配置非常简单VueX ： 支持vuexVue Server Renderer ： 支持服务端渲染Vue-meta ： 支持meta标签配置 1.2 Nuxt项目创建 https://zh.nuxtjs.org/guide/installation#新手模板 123456789101112131415//1.创建nuxt项目 https://www.npmjs.com/package/create-nuxt-app$ npx create-nuxt-app nuxt-learn//2.nuxt模式选择Universal spa是单页，所以只有一个入口文件，不利于搜索引擎收录 Universal 通用app，服务器渲染的 Vue.js 应用程序也可以被认为是&quot;同构&quot;或&quot;通用&quot;，因为应用程序的大部分代码都可以在服务器和客户端上运行//3.注意不要选择pretty(会和eslint冲突) 我们都知道，如何与团队其他人高效地进行协作开发是多人团队的一个痛点。 每个人都有独立的编码习惯，虽然团队可以通过制定强制执行的规范来保持大家代码风格的尽量一致。 但是，在实际编码过程中，个人可能会不经意地继续使用着自己的代码风格，而等到发现不一致再解决又未免有点迟。 而ESLint正是为解决这类问题而生的。ESLint 由 JavaScript 红宝书 作者 Nicholas C. Zakas 编写， 2013 年发布第一个版本，t是一款当前应用十分广泛的JavaScript代码检查工具 //4.npm run dev 访问 http://localhost:3000/ 1.3 Nuxt基本使用 a) 路由 123456789101112//pages文件夹下面，文件名即路由#1.pages下新建search.vue&lt;template&gt; &lt;div&gt; 这是search页面 &lt;/div&gt;&lt;/template&gt;#2.index.vue使用路由&lt;nuxt-link to=&quot;/search&quot;&gt;到search页面&lt;/nuxt-link&gt; b) 嵌套子模板 12345678910111213141516171819202122#index.vue#1.template&lt;template&gt; &lt;section class=&quot;container&quot;&gt; &lt;div&gt; &lt;logo/&gt; &lt;/div&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt;#2. javascriptimport Logo from &#x27;~/components/Logo.vue&#x27;export default &#123; components: &#123; Logo &#125;&#125;&lt;/script&gt; c) layouts布局文件 默认情况下所有的页面都会默认使用layouts下面default.vue这个布局文件 123456789#default.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;头部&lt;/h1&gt; &lt;!--nuxt就相当于 router-view--&gt; &lt;nuxt/&gt; &lt;h1&gt;尾巴&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt; ​ 12345678910111213141516171819202122232425262728#自定义布局文件#1.layouts下新建一个user.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;用户页面头部&lt;/h1&gt; &lt;nuxt/&gt; &lt;h1&gt;用户页面底部&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; &#125;&lt;/script&gt;&lt;style lang=&quot;css&quot; scoped&gt; h1&#123; color:green &#125;&lt;/style&gt;#2.pages下的search.vue指定使用哪个布局文件&lt;script&gt; export default&#123; layout:&quot;user&quot; &#125;&lt;/script&gt; d) 全局的css文件 123456789#1.在assets下新建css/main.css#2.修改nuxt.config.css配置文件css: [ &#x27;element-ui/lib/theme-chalk/index.css&#x27;, &#x27;~/assets/css/main.css&#x27;],#3.重启服务 e) vuex的使用 在nuxt中使用vuex的时候无需new Vue.Store实例，nuxt会帮我们自动创建。默认情况下，会使用index.js这个store 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#1.store/index.jsexport const state = () =&gt; (&#123; list: [&#x27;a&#x27;,&#x27;b&#x27;], user:&#123;&#125;&#125;)export const mutations = &#123; increment (state,text) &#123; state.list.push(text); &#125;,&#125;export const actions = &#123;&#125;#2.store/city.jsexport const state = () =&gt; (&#123; list: [&#x27;c&#x27;,&#x27;d&#x27;]&#125;)export const mutations = &#123; increment (state,text) &#123; state.list.push(text); &#125;&#125;#3.pages/city.vue&lt;template&gt; &lt;div&gt; Page is city &lt;ul&gt; &lt;li v-for=&quot;(item,idx) in $store.state.list&quot; :key=&quot;idx&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;input type=&quot;button&quot; value=&quot;增加信息index&quot; @click=&quot;addIndex&quot;&gt; &lt;li v-for=&quot;(item,idx) in $store.state.city.list&quot; :key=&quot;idx&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;input type=&quot;button&quot; value=&quot;增加信息city&quot; @click=&quot;addCity&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import axios from &quot;axios&quot; export default&#123; data()&#123; return &#123; list:[] &#125; &#125;, methods: &#123; addIndex()&#123; this.$store.commit(&#x27;increment&#x27;, &quot;kk&quot;) &#125;, addCity()&#123; this.$store.commit(&#x27;city/increment&#x27;, &quot;jj&quot;) &#125; &#125; &#125;&lt;/script&gt; 1.4 async和await async和await提供了一个很好的框架来编写易于读写的异步代码。有了async/await，我们很少需要写promise.then/catch 1.4.1 async 函数前面的async一词意味着一个简单的事情：这个函数总是返回一个promise，如果代码中有return &lt;非promise&gt;语句，JavaScript会自动把返回的这个value值包装成promise的resolved值。如果 async 函数没有返回值，它会返回 Promise.resolve(undefined)。 12345678910111213async function f() &#123; return 1&#125;//上面代码和下面代码等效async function f() &#123; //Promise.resolve方法返回一个promise的实例 return Promise.resolve(1)&#125;//放在一个函数前的async有两个作用：1.使函数总是返回一个promise2.允许在这其中使用await 1.4.2 await 关键词 await可以让JavaScript进行等待，直到一个promise执行并返回它的结果，JavaScript才会继续往下执行。 12345678910111213async function f() &#123; let promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(&#x27;done!&#x27;), 1000) &#125;) let result = await promise // 直到promise返回一个resolve值（*） alert(result) // &#x27;done!&#x27; &#125;f()//promise前面的await关键字能够使JavaScript等待，直到promise处理结束。然后：1.如果它是一个错误，异常就产生了，就像在那个地方调用了throw error一样。可以使用try catch处理异常2.否则它会返回一个结果，我们可以将它分配给一个值 1.5 SPA\\SEO\\SSR 1.5.1 SPA:单页面应用 SPA 时代，主要是在客户端端使用了history或hash（主要是为了低版本浏览器的兼容）API，在首次请求经服务端路由输出整个应用程序后，接下来的路由都由前端掌控了，前端通过路由作为中心枢纽控制一系列页面（组件）的渲染(DOM的生成)加载和数据交互。 优点 123页面之间的切换非常快一定程度减少了后端服务器的压力后端程序只需要提供api，不需要客户端到底是web端还是手机等 缺点 12首屏打开速度很慢，因为用户首次加载需要先下载SPA框架及应用程序的代码，然后在客户端渲染页面。不利于SEO搜索引擎优化 1.5.2 SEO:搜索引擎优化 SEO是一种通过了解搜索引擎的运作规则（如何抓取网站页面，如何索引以及如何根据特定的关键字展现搜索结果排序等）来调整网站，以提高该网站在搜索引擎中某些关键词的搜索结果排名。 我们之前说SPA单页面应用，通过AJAX获取数据，这就难保证我们的页面能被搜索引擎正常收到，并且有一些搜索引擎不支持执行js和通过ajax获取数据，那就更不用提SEO了。为了解决这个问题，SSR登场了 1.5.3 SSR:服务器端渲染 为了解决SPA不支持SEO的问题，我们也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，但是这样的HTML页面还不具备交互能力，所以还需要与SPA框架配合，在浏览器上“混合”成可交互的应用程序。 基本流程是： 在浏览器第一次访问某个 URI 资源的时候（首屏），Web 服务器根据路由拿到对应数据渲染并输出，且输出的数据中包含两部分： 路由页对应的页面及已渲染好的数据 完整的SPA程序代码 1在客户端首屏渲染完成之后，此时我们看到的其实已经是一个和之前的 SPA 相差无几的应用程序了，接下来我们进行的任何操作都只是客户端的应用进行交互，页面&#x2F;组件由Web端渲染，路由也由浏览器控制，用户只需要和当前浏览器内的应用打交道就可以了。 SSR优点 12更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。更快的内容到达时间(time-to-content)，不用等待所有的JS都下载完成，浏览器便能显示比较完整的页面了 SSR缺点 123占用更多的cpu和内存资源一些常用的浏览器的api可能无法正常使用，比如window，document，alert等，如果使用的话需要对运行环境加以判断开发调试会有一些麻烦，因为涉及到了浏览器及服务器，对于SPA的一些组件的生命周期的管理会变得复杂 1.5.4 Nuxt对SSR支持 从头搭建一个服务端渲染的应用是相当复杂的。幸运的是，我们有一个优秀的社区项目 Nuxt.js 让这一切变得非常简单。Nuxt 是一个基于 Vue 生态的更高层的框架，为开发服务端渲染的 Vue 应用提供了极其便利的开发体验。 Nuxt.js 是使用 Webpack 和 Node.js 进行封装的基于Vue的SSR框架，预设了利用Vue.js开发服务端渲染的应用所需要的各种配置，使用它你可以不需要自己搭建一套 SSR 程序，而是通过其约定好的文件结构和API就可以实现一个首屏渲染的 Web 应用。 Nuxt.js 主要关注的是应用的 UI渲染。 https://juejin.im/post/58ff960ba22b9d0065b722cd 1.6 数据预取 1.6.1 准备服务器接口 12345678910111213141516#1.server/interface/city.jsvar express = require(&#x27;express&#x27;)var router = express.Router()router.get(&#x27;/info&#x27;, function (req, res) &#123; return res.status(200).json([&#x27;北京&#x27;,&#x27;天津&#x27;])&#125;)module.exports = router#2.server/index.jsconst cityInterface = require(&quot;./interface/city&quot;)//在app.use(nuxt.render)上面添加app.use(&quot;/city&quot;,cityInterface)app.use(&quot;/city&quot;,cityInterface);app.use(nuxt.render)#.重启服务 localhost:3000/city/info 测试接口 1.6.2 不使用数据预取 1234567891011121314151617181920212223242526272829#1.客户端pages下新建city.vue&lt;template&gt; &lt;div&gt; Page is city &lt;ul&gt; &lt;li v-for=&quot;(item,idx) in list&quot; :key=&quot;idx&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import axios from &quot;axios&quot; export default&#123; data()&#123; return &#123; list:[] &#125; &#125;, //async表示方法返回一个Promise //await 同步等待 async mounted()&#123; let &#123;status,data&#125; = await axios.get(&quot;/city/info&quot;); this.list = data; console.log(this.list); &#125; &#125;&lt;/script&gt; 1.6.3 Nuxt.js工作流 nuxtServerInit：如果在状态树(store)中指定了 nuxtServerInit 方法，Nuxt.js 调用它的时候会将页面的上下文对象作为第2个参数传给它（仅在服务端调用）。当我们想将服务端的一些数据传到客户端时，这个方法是非常好用的 middleware：中间件允许您定义一个自定义函数运行在一个页面或一组页面渲染之前，服务端首屏渲染和路由跳转前均执行对应中间件。可以用作页面跳转时验证用户信息操作(登陆拦截)。 asyncData会在组件加载前（限于页面组件）调用，可以在服务端首屏渲染或者在路由跳转时执行，专门用来请求数据，Nuxt.js 会将 asyncData 返回的数据融合组件 data 方法返回的数据一并返回给当前组件。asyncData应该是用于影响SEO的内容，也就是需要让爬虫读取的内容。 1.6.4 服务端数据预取 a) nuxtServerInit nuxtServerInit可以将服务端的数据通过vuex同步到客户端，该方法仅会在服务端首屏渲染时执行 12345678910111213141516171819202122232425262728293031323334#store/index.jsexport const state = () =&gt; (&#123; list: [],&#125;)export const mutations = &#123; setlist (state,text) &#123; text.forEach(item=&gt;&#123; state.list.push(item) &#125;) &#125;,&#125;export const actions = &#123; //将菜单信息写入到vuex实例中 async nuxtServerInit (&#123; commit &#125;, &#123; req ,app &#125;) &#123; &#123; let &#123;status, data&#125; = await app.$axios.get(&quot;/city/info&quot;); commit(&#x27;setlist&#x27;, data) &#125; &#125;&#125;#2.pages/city.vue&lt;template&gt; &lt;div&gt; Page is city &lt;ul&gt; &lt;li v-for=&quot;(item,idx) in $store.state.list&quot; :key=&quot;idx&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; b) asyncData和fetch方法 123456789101112131415161718192021222324//使用asyncData进行ssr渲染async asyncData()&#123; //给data取别名，请求网址写全，因为在刷新浏览器的时候需要全路径请求服务器 let &#123;status,data:list&#125; = await axios.get(&quot;http://127.0.0.1:3000/city/info&quot;); if(status == 200) &#123; //这边不能使用this.list = list,因为获取不到this //通过return给页面返回数据 return &#123; list &#125; &#125;&#125;async fetch (&#123; store, params &#125;)&#123; //当页面加载时触发可以执行请求来触发action来修改state //不可以return数据给页面 //页面可以从this.$store中获取action修改的state let &#123;status,data:list&#125; = await axios.get(&quot;http://127.0.0.1:3000/city/info&quot;); store.commit(&#x27;setlist&#x27;, list)&#125;#注意点：asyncData 和 fetch都只能够在页面组件中使用，如果想要在页面组件的子组件中使用ssr，可以使用nuxtServerInit#注意点：由于 asyncData方法是在组件初始化前被调用的，所以在方法内是没有办法通过this来引用组件的实例。#注意点：当用户请求页面时候服务端会先使用SSR来生成对应的页面文档结构，而在用户切换路由则是使用了SPA的模式。这意味着如果用户刷新页面，asyncData方法会在服务端执行；如果用户通过nuxt-link路由导航到当前页面，asyncData会在客户端执行 1.6.5 客户端数据预取 当asyncData方法是由路由跳转触发的时候，则使用客户端数据预取，asyncData方法会在客户端执行。可以通过控制台打印来查看是在浏览器执行还是在node执行就可以验证了。 12345678910111213141516171819//https://zh.nuxtjs.org/api/#asyncdata-%E6%96%B9%E6%B3%95async asyncData(context)&#123; //给data取别名，请求网址写全 let &#123;status,data:list&#125; = await axios.get(&quot;http://127.0.0.1:3000/city/info&quot;); //如果是客户端执行，则可以使用window对象 //如果是服务端执行，则没有window对象 if(process.client)&#123; console.log(window) &#125; if(status == 200) &#123; //这边不能使用this.list = list,因为获取不到this //通过return给页面返回数据 return &#123; list &#125; &#125;&#125; 1.7 SSR原理 官方文档:https://ssr.vuejs.org/zh/ 如上图所示：webpack将 Source 打包出两个bundle文件。 服务端渲染：Server Bundle用于服务端渲染，主要是获取异步数据，同步到组件中，并将组件渲染成HTML返回到前端，但是vue-ssr不能绑定javascript事件，也就是说服务器端使用vue-ssr渲染出来的返回到浏览器的也只能是HTML+CSS。 客户端渲染：Client Bundle 用于客户端渲染，之前说过服务器不能增加事件，那只能前端增加。所以我们看到SSR渲染的网页源码中有window.__NUXT__=...代码，这是后端和前端在使用vuex共享数据。后端从vuex里面取到数据之后渲染成真正的HTML和css返回。客户端也是从vuex里面取到数据，客户端的渲染主要做2件事： 1.拿到数据，使用 virtual-dom进行预渲染，然后和服务端渲染出来的进行比对，比对两边渲染的内容是不是一致的 2.对DOM元素的事件进行绑定，也就是回答的问题，事件在这块进行的处理","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[]},{"title":"vue样式穿透","slug":"vue样式穿透","date":"2019-05-02T04:41:06.000Z","updated":"2020-03-29T04:47:01.236Z","comments":true,"path":"2019/05/02/vue样式穿透/","link":"","permalink":"http://yoursite.com/2019/05/02/vue%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F/","excerpt":"","text":"1.什么是scoped 1在Vue文件中的style标签上有一个特殊的属性，scoped。当一个style标签拥有scoped属性时候，它的css样式只能用于当前的Vue组件，可以使组件的样式不相互污染。如果一个项目的所有style标签都加上了scoped属性，相当于实现了样式的模块化。 2.scoped的实现原理 Vue中的scoped属性的效果主要是通过PostCss实现的。以下是转译前的代码: 12345678&lt;style scoped lang&#x3D;&quot;less&quot;&gt; .example&#123; color:red; &#125;&lt;&#x2F;style&gt;&lt;template&gt; &lt;div class&#x3D;&quot;example&quot;&gt;scoped测试案例&lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 转译后: 123456.example[data-v-5558831a] &#123; color: red;&#125;&lt;template&gt; &lt;div class&#x3D;&quot;example&quot; data-v-5558831a&gt;scoped测试案例&lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 既:PostCSS给一个组件中的所有dom添加了一个独一无二的动态属性，给css选择器额外添加一个对应的属性选择器，来选择组件中的dom,这种做法使得样式只作用于含有该属性的dom元素(组件内部的dom)。 总结：scoped的渲染规则： 给HTML的dom节点添加一个不重复的data属性(例如: data-v-5558831a)来唯一标识这个dom 元素 在每句css选择器的末尾(编译后生成的css语句)加一个当前组件的data属性选择器(例如：[data-v-5558831a])来私有化样式 3.scoped穿透 scoped看起来很好用，当时在Vue项目中，当我们引入第三方组件库时(如使用vue-awesome-swiper实现移动端轮播)，需要在局部组件中修改第三方组件库的样式，而又不想去除scoped属性造成组件之间的样式覆盖。这时我们可以通过特殊的方式穿透scoped。 stylus的样式穿透 使用&gt;&gt;&gt; 12345 外层 &gt;&gt;&gt; 第三方组件 样式 .wrapper &gt;&gt;&gt; .swiper-pagination-bullet-active background: #fff sass和less的样式穿透 使用/deep/ 123456外层 &#x2F;deep&#x2F; 第三方组件 &#123; 样式&#125;.wrapper &#x2F;deep&#x2F; .swiper-pagination-bullet-active&#123; background: #fff;&#125; 3.在组件中修改第三方组件库样式的其它方法 上面我们介绍了在使用scoped 属性时，通过scopd穿透的方式修改引入第三方组件库样式的方法，下面我们介绍其它方式来修改引入第三方组件库的样式 在vue组件中不使用scoped属性 在vue组建中使用两个style标签，一个加上scoped属性，一个不加scoped属性，把需要覆盖的css样式写在不加scoped属性的style标签里 建立一个reset.css(基础全局样式)文件，里面写覆盖的css样式，在入口文件main.js 中引入","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[]},{"title":"vue-cli的使用","slug":"vue-cli的使用","date":"2019-03-29T05:36:06.000Z","updated":"2020-03-29T05:48:14.641Z","comments":true,"path":"2019/03/29/vue-cli的使用/","link":"","permalink":"http://yoursite.com/2019/03/29/vue-cli%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1.vue-cli使用 vue-cli是vue官网提供的一个脚手架，这个构建工具大大降低了webpack的使用难度，支持热更新，有webpack-dev-server的支持，相当于启动了一个请求服务器，给你搭建了一个测试环境，只关注开发就OK 1.1 安装vue-cli创建项目 1231.npm install -g @vue&#x2F;cli@3.9.12.将配置环境变量 C:\\dev\\nodejs3.vue create project-name 1234567891011//查看最终生效的 webpack 配置信息vue inspect &gt; output.js//配置文件参考文档https://cli.vuejs.org/zh/config/#devserver-proxy//运行Appnpm run serve//编译Appnpm run build 1.2 windows(32位) npm装不上vue/cli的问题 1.3 vue.config.js配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//官网配置： https://cli.vuejs.org/zh/config/#filenamehashingconst path = require(&#x27;path&#x27;);const debug = process.env.NODE_ENV !== &#x27;production&#x27;module.exports = &#123; //部署应用包时的基本URL，如果是生产环境，部署到 /cli-study/dist 路径；如果是开发环境，部署到根路径 publicPath: !debug ? &#x27;/cli-study/dist&#x27; : &#x27;/&#x27;, //输出文件路径 outputDir: &#x27;dist&#x27;, //放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录。 assetsDir: &#x27;static&#x27;, //默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存 filenameHashing: true, // eslint-loader 是否在保存的时候检查 lintOnSave: false, // 是否使用包含运行时编译器的Vue构建版本，设置为 true 后你就可以在 Vue 组件中使用 template 选项了，但是这会让你的应用额外增加 10kb 左右。 runtimeCompiler: true, // 默认情况下 babel-loader 会忽略所有 node_modules 中的文件。如果你想要通过 Babel 显式转译一个依赖，可以在这个选项中列出来。 transpileDependencies: [], // 生产环境不需要sourceMap productionSourceMap: false, // 官网：https://cli.vuejs.org/zh/guide/webpack.html#%E7%AE%80%E5%8D%95%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F // 更多配置参考：https://www.jb51.net/article/150844.htm configureWebpack: config =&gt; &#123; Object.assign(config, &#123; // 开发生产共同配置 resolve: &#123; alias: &#123; &#x27;@&#x27;: path.resolve(__dirname, &#x27;./src&#x27;), &#x27;vue$&#x27;: &#x27;vue/dist/vue.esm.js&#x27; &#125; &#125; &#125;) &#125;, // webpack的链式操作，允许对内部的 webpack 配置进行更细粒度的修改 // 参考： https://cli.vuejs.org/zh/guide/webpack.html#%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C-%E9%AB%98%E7%BA%A7 chainWebpack: (config) =&gt; &#123; if (debug) &#123; // 本地开发配置 &#125; else &#123; // 生产开发配置 &#125; &#125;, // css的相关配置 css: &#123; &#125;, //所有 webpack-dev-server 的选项都支持 devServer: &#123; open: true, host: &#x27;127.0.0.1&#x27;, port: 3000, https: false, hotOnly: false, proxy: null, &#125;, // 第三方插件配置 pluginOptions: &#123;&#125;&#125;; 1.4 vue-cli搭建项目 1vue create project_name 1.5 Eslint格式化.vue文件 ESLint是一个用来识别 ECMAScript 并且按照规则给出报告的代码检测工具，使用它可以避免低级错误和统一代码的风格。 你可能有疑问，在.vue 文件中你怎么检验你的代码，因为它不是 JavaScript。我们假设你使用 ESLint (如果你没有使用话，你应该去使用！)。 你还需要官方的 eslint-plugin-vue，它支持同时检查你.vue文件中的模板和脚本。 https://vue-loader-v14.vuejs.org/zh-cn/workflow/linting.html a) eslint配置(rules规则) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// 关闭必须使用单引号&quot;quotes&quot;: [0, &quot;single&quot;],// 允许多余的换行&quot;no-multi-spaces&quot;: 0,&#x27;no-console&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;error&#x27; : &#x27;off&#x27;,&#x27;no-debugger&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;error&#x27; : &#x27;off&#x27;,&#x27;prefer-promise-reject-errors&#x27;: 0,&#x27;space-unary-ops&#x27;: 0,&#x27;no-unused-expressions&#x27;: 0,&#x27;no-useless-return&#x27;: 0,&#x27;standard/no-callback-literal&#x27;: 0,&#x27;import/first&#x27;: 0,&#x27;import/export&#x27;: 0,&#x27;no-mixed-operators&#x27;: 0,&#x27;no-use-before-define&#x27;: 0,// 不允许使用分号&#x27;semi&#x27;: [2, &#x27;never&#x27;],// 允许使用==&#x27;eqeqeq&#x27;: 0,// 缩进使用不做限制&#x27;indent&#x27;: 2,// 允许使用tab&#x27;no-tabs&#x27;: 0,// 函数圆括号之前没有空格&#x27;space-before-function-paren&#x27;: [2, &#x27;never&#x27;],// 不要求块内空格填充格式&#x27;padded-blocks&#x27;: 0,// 不限制变量一起声明&#x27;one-var&#x27;: 0,// 条件语句中复制操作符需要用圆括号括起来&#x27;no-cond-assign&#x27;: [2, &#x27;except-parens&#x27;],// 允许使用条件表达式使用常量&#x27;no-constant-condition&#x27;: 2,// 单行可忽略大括号，多行不可忽略&#x27;curly&#x27;: [2, &#x27;multi-line&#x27;],// 不允许使用var变量&#x27;no-var&#x27;: 2,// 不允许出现多个空格&#x27;no-multi-spaces&#x27;: [&#x27;error&#x27;, &#123; ignoreEOLComments: true &#125;],&#x27;camelcase&#x27;: 0,// 对象字面量的键值空格风格&#x27;key-spacing&#x27;: 2,// if语句包含一个return语句， else就多余&#x27;no-else-return&#x27;: 2,// 建议将经常出现的数字提取为变量&#x27;no-magic-numbers&#x27;: [0, &#123; ignoreArrayIndexes: true &#125;],// 不允许重复声明变量&#x27;no-redeclare&#x27;: [2, &#123; builtinGlobals: true &#125;],// 立即执行函数风格&#x27;wrap-iife&#x27;: [2, &#x27;inside&#x27;],// 不允许圆括号中出现空格&#x27;space-in-parens&#x27;: [2, &#x27;never&#x27;],// 确保运算符周围有空格&#x27;space-infix-ops&#x27;: 2,// 强制点号与属性同一行&#x27;dot-location&#x27;: [2, &#x27;property&#x27;],// 强制单行代码使用空格&#x27;block-spacing&#x27;: [2, &#x27;always&#x27;],// 约束for-in使用hasOwnProperty判断&#x27;guard-for-in&#x27;: 0,// 采用one true brace style大括号风格&#x27;brace-style&#x27;: [2, &#x27;1tbs&#x27;, &#123; &#x27;allowSingleLine&#x27;: true &#125;],// 统一逗号周围空格风格&#x27;comma-spacing&#x27;: [2, &#123; &#x27;before&#x27;: false, &#x27;after&#x27;: true &#125;],// 禁止出现多个空行&#x27;no-multiple-empty-lines&#x27;: [2, &#123; &#x27;max&#x27;: 1, &#x27;maxEOF&#x27;: 2 &#125;],// 允许箭头函数不使用圆括号&#x27;arrow-parens&#x27;: 0,// 规范generator函数的使用&#x27;generator-star-spacing&#x27;: [2, &#123; &#x27;before&#x27;: false, &#x27;after&#x27;: true &#125;],// 要求在块级&#x27;lines-around-comment&#x27;: [2, &#123; &#x27;beforeBlockComment&#x27;: true, &#x27;afterBlockComment&#x27;: false, &#x27;beforeLineComment&#x27;: true, &#x27;afterLineComment&#x27;: false &#125;]&quot;off&quot;或者0，不启用这个规则&quot;warn&quot;或者1，出现问题会有警告&quot;error&quot;或者2，出现问题会报错 https://github.com/vuejs/eslint-plugin-vue/blob/master/docs/rules/README.md 注意：“extends”: “plugin:vue/recommended” 会同时检查js和模板的语法错误 12vscode中通过 npm run lint会自动进行eslint的校验和修正npm run lint --fix","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[]},{"title":"vue双向数据绑定","slug":"vue双向数据绑定","date":"2019-03-21T04:37:26.000Z","updated":"2020-03-29T04:41:36.098Z","comments":true,"path":"2019/03/21/vue双向数据绑定/","link":"","permalink":"http://yoursite.com/2019/03/21/vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/","excerpt":"","text":"vue双向绑定的原理 a) 页面–&gt;数据 view更新data只需要添加DOM事件监听即可，比如input标签监听 ‘input’ 事件就可以实现 b) 数据–&gt;页面 是通过数据劫持 + 发布者-订阅者模式的方式来实现的 (1).数据劫持 vue是通过Object.defineProperty()来实现数据劫持的。(vue3.0已换成proxy来实现数据劫持) 1234567891011121314var book = &#123;&#125;Object.defineProperty(book, &#x27;name&#x27;, &#123; set: function (value) &#123; name = value; console.log(&#x27;你取了一个书名叫做&#x27; + value); &#125;, get: function () &#123; return &#x27;《&#x27; + name + &#x27;》&#x27; &#125;&#125;)book.name = &#x27;vue权威指南&#x27;; // 你取了一个书名叫做vue权威指南book.name = &#x27;vue权威指南2&#x27;; // 你取了一个书名叫做vue权威指南console.log(book.name); // 《vue权威指南》 (2).发布者订阅模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//订阅器function Dept() &#123; this.watchers = [];&#125;Dept.prototype.addWatcher = function (watcher) &#123; this.watchers.push(watcher);&#125;Dept.prototype.notifyWatcher = function (value) &#123; this.watchers.forEach(function (watcher) &#123; watcher.update(value); &#125;);&#125;//订阅者function Watcher(name)&#123; this.name = name;&#125;Watcher.prototype.update = function(value)&#123; console.log(this.name+&quot;接收到新天气&quot;+value+&quot;，准备干啥&quot;);&#125;//创建几个订阅者var xiaoming = new Watcher(&quot;小明&quot;);var xiaohong = new Watcher(&quot;小红&quot;);var xiaohei = new Watcher(&quot;小黑&quot;);//创建一个订阅器var dept = new Dept();dept.addWatcher(xiaoming);dept.addWatcher(xiaohong);dept.addWatcher(xiaohei);//数据劫持常用方案：Object.defineProperty(Vue 2.0) Proxy(Vue 3.0)//数据劫持的主要作用：劫持数据的变化var weatherStation = &#123;&#125;;Object.defineProperty(weatherStation, &quot;weather&quot;, &#123; //当在外部给book的name属性赋值的时候，会执行set set: function (value) &#123; name = value; //一旦天气变化，订阅器通知所有的观察者去更新 dept.notifyWatcher(value); &#125;, //当在外部获取book的name属性的时候，会执行get get: function () &#123; return &quot;当前天气是&quot; + name; &#125;&#125;)weatherStation.weather = &quot;晴天&quot;;weatherStation.weather = &quot;冰雹&quot;; (3).数据绑定的实现流程 首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。 因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。 接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。 因此接下去我们执行以下3个步骤，实现数据的双向绑定： 1.监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知所有订阅者。 2.订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。 3.解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅者","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[]},{"title":"微信公众号开发","slug":"微信公众号开发","date":"2018-06-12T07:39:44.000Z","updated":"2020-04-14T07:44:40.172Z","comments":true,"path":"2018/06/12/微信公众号开发/","link":"","permalink":"http://yoursite.com/2018/06/12/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/","excerpt":"","text":"1.微信公众号开发 1.1 公众号分类 微信公众平台是腾讯旗下的一个平台，微信公众平台中有以下三种微信公众号类型： 12341、订阅号2、服务号3、企业号：企业号多半是企业内容使用，用于管理员工通讯，方便员工通讯，信息集合和消息通知等功能，相当与一个移动的小型oa系统了。一般不用来对外宣传推广 服务号和订阅号的区别： 123451.出现的位置不同2.单月发送的消息数量不同，订阅号每天1篇，服务号每月4篇3.订阅号没有9大接口和支付功能 9大接口包括：语音识别、客服接口、OAuth 2.0网页授权、生成带参数的二维码、获取用户地理位置、获取用户基本信息、获取关注者列表、用户分组接口、上传和下载多媒体文件 微信公众号认证账号和非认证账号的区别：认证账号就是可以在添加好友里根据名字搜索到该账号 1.2 公众号注册 1.3 微信公众号基本功能 1.3.1 自动回复 https://kf.qq.com/faq/161221FZnEfe161221Ibmamq.html 12收到消息回复在一小时内只能回复一到两条，所有有必要设置关键词回复 1.3.2 自定义菜单 http://classic.getemoji.com/ 可以在这个网址中选择对应的图标，给菜单的名字添加图标 1.3.3 投票管理 投票管理需要插入到对应的文章后才能生效 1.3.4 页面模板使用 a) 添加页面模板 b) 绑定页面模板 1.4 公众号后台开发 除了使用上面所提到的直接在微信公众号后台配置的基本功能之外，微信公众号还允许我们接入后台程序。需要注意的是，一旦后台接入之后，之前的配置会自动失效。 1.4.1 后台接入 a) 微信公众号后台配置 b) node后台 12345678910111213141516171819202122232425262728293031323334353637383940var express = require(&#x27;express&#x27;);var parseString = require(&#x27;xml2js&#x27;).parseString;//引入xml2js包var app = express();const sha1 = require(&#x27;sha1&#x27;);const config = &#123; appID: &#x27;wx16b01d87eca9d8f4&#x27;, //公众号里面取 AppSecret: &#x27;41458d7494fe25ed6d957a7632d72cfa&#x27;, //公众号里面取 token: &#x27;mytoken1234&#x27; //自定义的token&#125;app.use(function (req, res, next) &#123; console.log(req.method) if (req.method == &#x27;GET&#x27;) &#123; var signature = req.query.signature, timestamp = req.query.timestamp, nonce = req.query.nonce, echostr = req.query.echostr; // token、timestamp、nonce三个参数进行字典序排序 var arr = [config.token, timestamp, nonce].sort().join(&#x27;&#x27;); // sha1加密 var result = sha1(arr); console.log(result, signature) if (result === signature) &#123; res.send(echostr); &#125; else &#123; res.send(&#x27;mismatch&#x27;); &#125; &#125; else&#123; next() &#125;&#125;);app.listen(8000, () =&gt; &#123; console.log(&quot;running....&quot;)&#125;) c) 将node后台端口通过ngrok映射到外网 d) 后台接入流程 1.4.2 回复消息 https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Passive_user_reply_message.html 公众号的接口权限可在后台查询，微信公众号在定义客户端和服务端交互的时候，使用的数据格式是xml。 12345678&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;&#x2F;ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;&#x2F;FromUserName&gt; &lt;CreateTime&gt;12345678&lt;&#x2F;CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;&#x2F;MsgType&gt; &lt;Content&gt;&lt;![CDATA[你好]]&gt;&lt;&#x2F;Content&gt;&lt;&#x2F;xml&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 处理微信post消息请求 */app.post(&#x27;/&#x27;, function (req, res) &#123; try &#123; var buffer = []; //监听 data 事件 用于接收数据 req.on(&#x27;data&#x27;, function (data) &#123; buffer.push(data); &#125;); //监听 end 事件 用于处理接收完成的数据 req.on(&#x27;end&#x27;, function () &#123; //输出接收完成的数据 parseString(Buffer.concat(buffer).toString(&#x27;utf-8&#x27;), &#123; explicitArray: false &#125;, function (err, result) &#123; if (err) &#123; //打印错误信息 console.log(err); &#125; else &#123; //打印解析结果 console.log(result); result = result.xml; var toUser = result.ToUserName; //接收方微信 var fromUser = result.FromUserName;//发送仿微信 if (result.Event === &#x27;subscribe&#x27;) &#123; //回复消息 var xml = returntext(fromUser, toUser, &#x27;欢迎关注公众号,hahhh&#x27;); console.log(xml) res.send(xml) &#125; else &#123; var xml = returntext(fromUser, toUser, &#x27;您好&#x27;); console.log(xml) res.send(xml) &#125; &#125; &#125;) &#125;); &#125; catch (err) &#123; console.log(err) &#125;&#125;)//回复文本消息function returntext(toUser, fromUser, content) &#123; var xmlContent = &quot;&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[&quot; + toUser + &quot;]]&gt;&lt;/ToUserName&gt;&quot;; xmlContent += &quot;&lt;FromUserName&gt;&lt;![CDATA[&quot; + fromUser + &quot;]]&gt;&lt;/FromUserName&gt;&quot;; xmlContent += &quot;&lt;CreateTime&gt;&quot; + new Date().getTime() + &quot;&lt;/CreateTime&gt;&quot;; xmlContent += &quot;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&quot;; xmlContent += &quot;&lt;Content&gt;&lt;![CDATA[&quot; + content + &quot;]]&gt;&lt;/Content&gt;&lt;/xml&gt;&quot;; return xmlContent;&#125; 1.4.3 重新开启自定义菜单 当接入公众号后台之后，原来的自定义菜单、回复等功能会失效。如果想自定义菜单和公众号后台同时生效，我们可以在添加功能插件–&gt;自定义菜单中开启。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[]},{"title":"函数原型","slug":"函数原型","date":"2018-02-14T08:04:59.000Z","updated":"2020-04-14T08:08:10.289Z","comments":true,"path":"2018/02/14/函数原型/","link":"","permalink":"http://yoursite.com/2018/02/14/%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B/","excerpt":"","text":"一、函数声明的实质 我们平时大量使用Function，但是真的懂Function吗？ 声明一个函数的时所使用的代码 123function fn(num1,num2)&#123; return num1+num2;&#125; 其实它的实质是使用了Function的构造函数 12&#x2F;&#x2F;Function(参数1，参数2，...，函数体);var fn &#x3D; new Function(&#39;num1&#39;,&#39;num2&#39;,&#39;return num1+num2&#39;); 这两种声明方式是等同的，但从第二种写法上，我们可以很清晰的看出fn函数是由Function构造出来的。 二、JavaScript对象 我们先来看一个例子 12console.log(typeof Object);console.log(typeof Function); 打印结果都是Function，这是为什么了，为什么Object也是Function？ 那是因为JS中所有的函数都是Function的实例，Object也是由构造函数构建的，那么Object的类型也是Function。 值得注意的是：**Function自身能够生成自身，即Function的原型就是Function。**即 我们用一张图来解释这其中的关系 结合上一章所介绍的原型链，综合给出一张关系图 [声明]：本篇文章中部分引用 从Function说原型 的文章。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[]}],"categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[]}