{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"vue-cli的使用","slug":"vue-cli的使用","date":"2019-03-29T05:36:06.000Z","updated":"2020-03-29T05:48:14.641Z","comments":true,"path":"2019/03/29/vue-cli的使用/","link":"","permalink":"http://yoursite.com/2019/03/29/vue-cli%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"1.vue-cli使用vue-cli是vue官网提供的一个脚手架，这个构建工具大大降低了webpack的使用难度，支持热更新，有webpack-dev-server的支持，相当于启动了一个请求服务器，给你搭建了一个测试环境，只关注开发就OK 1.1 安装vue-cli创建项目1231.npm install -g @vue&#x2F;cli@3.9.12.将配置环境变量 C:\\dev\\nodejs3.vue create project-name 1234567891011//查看最终生效的 webpack 配置信息vue inspect &gt; output.js//配置文件参考文档https://cli.vuejs.org/zh/config/#devserver-proxy//运行Appnpm run serve//编译Appnpm run build 1.2 windows(32位) npm装不上vue/cli的问题 1.3 vue.config.js配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//官网配置： https://cli.vuejs.org/zh/config/#filenamehashingconst path = require(&#x27;path&#x27;);const debug = process.env.NODE_ENV !== &#x27;production&#x27;module.exports = &#123; //部署应用包时的基本URL，如果是生产环境，部署到 /cli-study/dist 路径；如果是开发环境，部署到根路径 publicPath: !debug ? &#x27;/cli-study/dist&#x27; : &#x27;/&#x27;, //输出文件路径 outputDir: &#x27;dist&#x27;, //放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录。 assetsDir: &#x27;static&#x27;, //默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存 filenameHashing: true, // eslint-loader 是否在保存的时候检查 lintOnSave: false, // 是否使用包含运行时编译器的Vue构建版本，设置为 true 后你就可以在 Vue 组件中使用 template 选项了，但是这会让你的应用额外增加 10kb 左右。 runtimeCompiler: true, // 默认情况下 babel-loader 会忽略所有 node_modules 中的文件。如果你想要通过 Babel 显式转译一个依赖，可以在这个选项中列出来。 transpileDependencies: [], // 生产环境不需要sourceMap productionSourceMap: false, // 官网：https://cli.vuejs.org/zh/guide/webpack.html#%E7%AE%80%E5%8D%95%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F // 更多配置参考：https://www.jb51.net/article/150844.htm configureWebpack: config =&gt; &#123; Object.assign(config, &#123; // 开发生产共同配置 resolve: &#123; alias: &#123; &#x27;@&#x27;: path.resolve(__dirname, &#x27;./src&#x27;), &#x27;vue$&#x27;: &#x27;vue/dist/vue.esm.js&#x27; &#125; &#125; &#125;) &#125;, // webpack的链式操作，允许对内部的 webpack 配置进行更细粒度的修改 // 参考： https://cli.vuejs.org/zh/guide/webpack.html#%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C-%E9%AB%98%E7%BA%A7 chainWebpack: (config) =&gt; &#123; if (debug) &#123; // 本地开发配置 &#125; else &#123; // 生产开发配置 &#125; &#125;, // css的相关配置 css: &#123; &#125;, //所有 webpack-dev-server 的选项都支持 devServer: &#123; open: true, host: &#x27;127.0.0.1&#x27;, port: 3000, https: false, hotOnly: false, proxy: null, &#125;, // 第三方插件配置 pluginOptions: &#123;&#125;&#125;; 1.4 vue-cli搭建项目1vue create project_name 1.5 Eslint格式化.vue文件ESLint是一个用来识别 ECMAScript 并且按照规则给出报告的代码检测工具，使用它可以避免低级错误和统一代码的风格。 你可能有疑问，在.vue 文件中你怎么检验你的代码，因为它不是 JavaScript。我们假设你使用 ESLint (如果你没有使用话，你应该去使用！)。 你还需要官方的 eslint-plugin-vue，它支持同时检查你.vue文件中的模板和脚本。 https://vue-loader-v14.vuejs.org/zh-cn/workflow/linting.html a) eslint配置(rules规则)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// 关闭必须使用单引号&quot;quotes&quot;: [0, &quot;single&quot;],// 允许多余的换行&quot;no-multi-spaces&quot;: 0,&#x27;no-console&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;error&#x27; : &#x27;off&#x27;,&#x27;no-debugger&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;error&#x27; : &#x27;off&#x27;,&#x27;prefer-promise-reject-errors&#x27;: 0,&#x27;space-unary-ops&#x27;: 0,&#x27;no-unused-expressions&#x27;: 0,&#x27;no-useless-return&#x27;: 0,&#x27;standard/no-callback-literal&#x27;: 0,&#x27;import/first&#x27;: 0,&#x27;import/export&#x27;: 0,&#x27;no-mixed-operators&#x27;: 0,&#x27;no-use-before-define&#x27;: 0,// 不允许使用分号&#x27;semi&#x27;: [2, &#x27;never&#x27;],// 允许使用==&#x27;eqeqeq&#x27;: 0,// 缩进使用不做限制&#x27;indent&#x27;: 2,// 允许使用tab&#x27;no-tabs&#x27;: 0,// 函数圆括号之前没有空格&#x27;space-before-function-paren&#x27;: [2, &#x27;never&#x27;],// 不要求块内空格填充格式&#x27;padded-blocks&#x27;: 0,// 不限制变量一起声明&#x27;one-var&#x27;: 0,// 条件语句中复制操作符需要用圆括号括起来&#x27;no-cond-assign&#x27;: [2, &#x27;except-parens&#x27;],// 允许使用条件表达式使用常量&#x27;no-constant-condition&#x27;: 2,// 单行可忽略大括号，多行不可忽略&#x27;curly&#x27;: [2, &#x27;multi-line&#x27;],// 不允许使用var变量&#x27;no-var&#x27;: 2,// 不允许出现多个空格&#x27;no-multi-spaces&#x27;: [&#x27;error&#x27;, &#123; ignoreEOLComments: true &#125;],&#x27;camelcase&#x27;: 0,// 对象字面量的键值空格风格&#x27;key-spacing&#x27;: 2,// if语句包含一个return语句， else就多余&#x27;no-else-return&#x27;: 2,// 建议将经常出现的数字提取为变量&#x27;no-magic-numbers&#x27;: [0, &#123; ignoreArrayIndexes: true &#125;],// 不允许重复声明变量&#x27;no-redeclare&#x27;: [2, &#123; builtinGlobals: true &#125;],// 立即执行函数风格&#x27;wrap-iife&#x27;: [2, &#x27;inside&#x27;],// 不允许圆括号中出现空格&#x27;space-in-parens&#x27;: [2, &#x27;never&#x27;],// 确保运算符周围有空格&#x27;space-infix-ops&#x27;: 2,// 强制点号与属性同一行&#x27;dot-location&#x27;: [2, &#x27;property&#x27;],// 强制单行代码使用空格&#x27;block-spacing&#x27;: [2, &#x27;always&#x27;],// 约束for-in使用hasOwnProperty判断&#x27;guard-for-in&#x27;: 0,// 采用one true brace style大括号风格&#x27;brace-style&#x27;: [2, &#x27;1tbs&#x27;, &#123; &#x27;allowSingleLine&#x27;: true &#125;],// 统一逗号周围空格风格&#x27;comma-spacing&#x27;: [2, &#123; &#x27;before&#x27;: false, &#x27;after&#x27;: true &#125;],// 禁止出现多个空行&#x27;no-multiple-empty-lines&#x27;: [2, &#123; &#x27;max&#x27;: 1, &#x27;maxEOF&#x27;: 2 &#125;],// 允许箭头函数不使用圆括号&#x27;arrow-parens&#x27;: 0,// 规范generator函数的使用&#x27;generator-star-spacing&#x27;: [2, &#123; &#x27;before&#x27;: false, &#x27;after&#x27;: true &#125;],// 要求在块级&#x27;lines-around-comment&#x27;: [2, &#123; &#x27;beforeBlockComment&#x27;: true, &#x27;afterBlockComment&#x27;: false, &#x27;beforeLineComment&#x27;: true, &#x27;afterLineComment&#x27;: false &#125;]&quot;off&quot;或者0，不启用这个规则&quot;warn&quot;或者1，出现问题会有警告&quot;error&quot;或者2，出现问题会报错 https://github.com/vuejs/eslint-plugin-vue/blob/master/docs/rules/README.md 注意：”extends”: “plugin:vue/recommended” 会同时检查js和模板的语法错误 12vscode中通过 npm run lint会自动进行eslint的校验和修正npm run lint --fix","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[]},{"title":"vue双向数据绑定","slug":"vue双向数据绑定","date":"2019-03-21T04:37:26.000Z","updated":"2020-03-29T04:41:36.098Z","comments":true,"path":"2019/03/21/vue双向数据绑定/","link":"","permalink":"http://yoursite.com/2019/03/21/vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/","excerpt":"","text":"vue双向绑定的原理a) 页面–&gt;数据view更新data只需要添加DOM事件监听即可，比如input标签监听 ‘input’ 事件就可以实现 b) 数据–&gt;页面是通过数据劫持 + 发布者-订阅者模式的方式来实现的 (1).数据劫持vue是通过Object.defineProperty()来实现数据劫持的。(vue3.0已换成proxy来实现数据劫持) 1234567891011121314var book = &#123;&#125;Object.defineProperty(book, &#x27;name&#x27;, &#123; set: function (value) &#123; name = value; console.log(&#x27;你取了一个书名叫做&#x27; + value); &#125;, get: function () &#123; return &#x27;《&#x27; + name + &#x27;》&#x27; &#125;&#125;)book.name = &#x27;vue权威指南&#x27;; // 你取了一个书名叫做vue权威指南book.name = &#x27;vue权威指南2&#x27;; // 你取了一个书名叫做vue权威指南console.log(book.name); // 《vue权威指南》 (2).发布者订阅模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//订阅器function Dept() &#123; this.watchers = [];&#125;Dept.prototype.addWatcher = function (watcher) &#123; this.watchers.push(watcher);&#125;Dept.prototype.notifyWatcher = function (value) &#123; this.watchers.forEach(function (watcher) &#123; watcher.update(value); &#125;);&#125;//订阅者function Watcher(name)&#123; this.name = name;&#125;Watcher.prototype.update = function(value)&#123; console.log(this.name+&quot;接收到新天气&quot;+value+&quot;，准备干啥&quot;);&#125;//创建几个订阅者var xiaoming = new Watcher(&quot;小明&quot;);var xiaohong = new Watcher(&quot;小红&quot;);var xiaohei = new Watcher(&quot;小黑&quot;);//创建一个订阅器var dept = new Dept();dept.addWatcher(xiaoming);dept.addWatcher(xiaohong);dept.addWatcher(xiaohei);//数据劫持常用方案：Object.defineProperty(Vue 2.0) Proxy(Vue 3.0)//数据劫持的主要作用：劫持数据的变化var weatherStation = &#123;&#125;;Object.defineProperty(weatherStation, &quot;weather&quot;, &#123; //当在外部给book的name属性赋值的时候，会执行set set: function (value) &#123; name = value; //一旦天气变化，订阅器通知所有的观察者去更新 dept.notifyWatcher(value); &#125;, //当在外部获取book的name属性的时候，会执行get get: function () &#123; return &quot;当前天气是&quot; + name; &#125;&#125;)weatherStation.weather = &quot;晴天&quot;;weatherStation.weather = &quot;冰雹&quot;; (3).数据绑定的实现流程首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。 因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。 接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。 因此接下去我们执行以下3个步骤，实现数据的双向绑定： 1.监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知所有订阅者。 2.订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。 3.解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅者","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[]}],"categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[]}